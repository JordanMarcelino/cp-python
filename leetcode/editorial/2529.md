# ðŸš€ [2529] [Maximum Count of Positive Integer and Negative Integer](../easy/2529.py)

## ðŸ“ Problem Statement

Given a **sorted** array `nums`, find the **maximum** count between:

-   The number of **positive** integers.
-   The number of **negative** integers.

ðŸ”¹ **0 is neither positive nor negative.**  
ðŸ”¹ **The array is sorted in non-decreasing order.**

---

## ðŸ”¹ Example Walkthrough

### **Example 1**

```python
Input: nums = [-2,-1,-1,1,2,3]
Output: 3
```

âœ… **Negative numbers**: `[-2, -1, -1]` â†’ count = `3`  
âœ… **Positive numbers**: `[1, 2, 3]` â†’ count = `3`  
âœ” **Maximum count**: `3`

---

### **Example 2**

```python
Input: nums = [-3,-2,-1,0,0,1,2]
Output: 3
```

âœ… **Negative numbers**: `[-3, -2, -1]` â†’ count = `3`  
âœ… **Positive numbers**: `[1, 2]` â†’ count = `2`  
âœ” **Maximum count**: `3`

---

### **Example 3**

```python
Input: nums = [5,20,66,1314]
Output: 4
```

âœ… **Negative numbers**: `[]` â†’ count = `0`  
âœ… **Positive numbers**: `[5, 20, 66, 1314]` â†’ count = `4`  
âœ” **Maximum count**: `4`

---

## ðŸ’¡ Efficient Approach (Binary Search)

### **ðŸ”¹ Idea**

Since the array is **sorted**, we can use **binary search** (`O(log N)`) to quickly find:

-   **`left`**: Index of the first `0` (or the first positive number) â†’ `bisect_left(nums, 0)`
-   **`right`**: Index of the first number greater than `0` â†’ `bisect_right(nums, 0)`

### **ðŸ”¹ Explanation**

1. **Negative count** â†’ `left` (since `nums[0:left]` contains all negatives).
2. **Positive count** â†’ `N - right` (since `nums[right:N]` contains all positives).
3. **Return the max of both counts**.

---

## ðŸ”¨ Python Implementation

```python
from bisect import bisect_left, bisect_right
from typing import List

class Solution:
    def maximumCount(self, nums: List[int]) -> int:
        N = len(nums)
        left = bisect_left(nums, 0)  # First index where 0 or positive appears
        right = bisect_right(nums, 0)  # First index where a positive number appears

        return max(left, N - right)
```

---

## ðŸ“ˆ Complexity Analysis

| Step                                              | Complexity            |
| ------------------------------------------------- | --------------------- |
| **Binary Search (`bisect_left`, `bisect_right`)** | \( O(log N) \)        |
| **Final Computation**                             | \( O(1) \)            |
| **Total Complexity**                              | **\( O(log N) \)** âœ… |

---

## ðŸ”¥ Key Takeaways

âœ” **Binary search** helps achieve **\( O(log N) \) efficiency.**  
âœ” **Handles edge cases** where all numbers are positive or negative.  
âœ” **Much faster than \( O(N) \) linear counting, especially for large arrays.**
