# ðŸš€ [3191] [Minimum Operations to Make Binary Array Elements Equal to One I](../medium/3191.py)

## ðŸ“ Problem Statement

Given a **binary array** `nums`, we can perform the following operation **any number of times**:

-   **Choose any 3 consecutive elements** and **flip** all of them (change `0 â†’ 1` and `1 â†’ 0`).

Return the **minimum number of operations** required to make **all elements** in `nums` equal to `1`.  
If **impossible**, return `-1`.

---

## ðŸ”¹ Example Walkthrough

### **Example 1**

```python
Input: nums = [0,1,1,1,0,0]
Output: 3
```

âœ… **Operations:**

1. Flip indices **(0,1,2)** â†’ `nums = [1,0,0,1,0,0]`
2. Flip indices **(1,2,3)** â†’ `nums = [1,1,1,0,0,0]`
3. Flip indices **(3,4,5)** â†’ `nums = [1,1,1,1,1,1]`

âœ” **Minimum operations**: `3`

---

### **Example 2**

```python
Input: nums = [0,1,1,1]
Output: -1
```

âŒ **Reason**:

-   There is **one `0` at the start** but **no way to flip it** because we need a group of `3` elements.

âœ” **Output**: `-1`

---

## ðŸ’¡ Efficient Greedy Approach

### **ðŸ”¹ Key Observations**

1. **We must fix each `0` from left to right** using a **greedy approach**.
2. The only way to flip `0` is by flipping **three consecutive elements**.
3. If the **last two elements** remain `0`, **it's impossible** to fix.

---

## ðŸ”¨ Python Implementation

```python
from typing import List

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        N = len(nums)
        ans = 0

        # Iterate through the array except the last two elements
        for i in range(N - 2):
            if nums[i] == 0:  # If we find a 0, flip a window of 3 elements
                nums[i] ^= 1
                nums[i + 1] ^= 1
                nums[i + 2] ^= 1
                ans += 1

        # If last two elements are still 0, return -1 (impossible)
        return -1 if nums[-1] == 0 or nums[-2] == 0 else ans
```

---

## ðŸ“ˆ Complexity Analysis

| Step                        | Complexity        |
| --------------------------- | ----------------- |
| **Iterating over `nums`**   | \( O(N) \)        |
| **Flipping three elements** | \( O(1) \)        |
| **Total Complexity**        | **\( O(N) \)** âœ… |

---

## ðŸ”¥ Key Takeaways

âœ” **Greedy Approach** ensures a **linear-time solution**.  
âœ” **Flipping in-place** avoids extra space usage.  
âœ” **Edge Case Handling** prevents impossible situations.
